{"ast":null,"code":"import { checkRequired, createValidator, createValidatorAsync, isEmpty, shallowEqual, formatErrorMessage, get } from './utils';\nimport { joinName } from './utils/formatErrorMessage';\nimport locales from './locales';\nexport const schemaSpecKey = 'objectTypeSchemaSpec';\n/**\n * Get the field type from the schema object\n */\nexport function getFieldType(schemaSpec, fieldName, nestedObject) {\n  if (nestedObject) {\n    const namePath = fieldName.split('.').join(`.${schemaSpecKey}.`);\n    return get(schemaSpec, namePath);\n  }\n  return schemaSpec === null || schemaSpec === void 0 ? void 0 : schemaSpec[fieldName];\n}\n/**\n * Get the field value from the data object\n */\nexport function getFieldValue(data, fieldName, nestedObject) {\n  return nestedObject ? get(data, fieldName) : data === null || data === void 0 ? void 0 : data[fieldName];\n}\nexport class MixedType {\n  constructor(name) {\n    this.required = false;\n    this.requiredMessage = '';\n    this.trim = false;\n    this.emptyAllowed = false;\n    this.rules = [];\n    this.priorityRules = [];\n    // The field name that depends on the verification of other fields\n    this.otherFields = [];\n    this.proxyOptions = {};\n    this.$typeName = name;\n    this.locale = Object.assign(name ? locales[name] : {}, locales.mixed);\n  }\n  setSchemaOptions(schemaSpec, value) {\n    this.$schemaSpec = schemaSpec;\n    this.value = value;\n  }\n  check(value = this.value, data, fieldName) {\n    if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {\n      return {\n        hasError: true,\n        errorMessage: formatErrorMessage(this.requiredMessage, {\n          name: this.fieldLabel || joinName(fieldName)\n        })\n      };\n    }\n    const validator = createValidator(data, fieldName, this.fieldLabel);\n    const checkResult = validator(value, this.priorityRules);\n    // If the priority rule fails, return the result directly\n    if (checkResult) {\n      return checkResult;\n    }\n    if (!this.required && isEmpty(value)) {\n      return {\n        hasError: false\n      };\n    }\n    return validator(value, this.rules) || {\n      hasError: false\n    };\n  }\n  checkAsync(value = this.value, data, fieldName) {\n    if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {\n      return Promise.resolve({\n        hasError: true,\n        errorMessage: formatErrorMessage(this.requiredMessage, {\n          name: this.fieldLabel || joinName(fieldName)\n        })\n      });\n    }\n    const validator = createValidatorAsync(data, fieldName, this.fieldLabel);\n    return new Promise(resolve => validator(value, this.priorityRules).then(checkResult => {\n      // If the priority rule fails, return the result directly\n      if (checkResult) {\n        resolve(checkResult);\n      }\n    }).then(() => {\n      if (!this.required && isEmpty(value)) {\n        resolve({\n          hasError: false\n        });\n      }\n    }).then(() => validator(value, this.rules)).then(checkResult => {\n      if (checkResult) {\n        resolve(checkResult);\n      }\n      resolve({\n        hasError: false\n      });\n    }));\n  }\n  pushRule(rule) {\n    var _a, _b;\n    const {\n      onValid,\n      errorMessage,\n      priority,\n      params\n    } = rule;\n    const nextRule = {\n      onValid,\n      params,\n      isAsync: rule.isAsync,\n      errorMessage: errorMessage || ((_b = (_a = this.rules) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.errorMessage)\n    };\n    if (priority) {\n      this.priorityRules.push(nextRule);\n    } else {\n      this.rules.push(nextRule);\n    }\n  }\n  addRule(onValid, errorMessage, priority) {\n    this.pushRule({\n      onValid,\n      errorMessage,\n      priority\n    });\n    return this;\n  }\n  addAsyncRule(onValid, errorMessage, priority) {\n    this.pushRule({\n      onValid,\n      isAsync: true,\n      errorMessage,\n      priority\n    });\n    return this;\n  }\n  isRequired(errorMessage = this.locale.isRequired, trim = true) {\n    this.required = true;\n    this.trim = trim;\n    this.requiredMessage = errorMessage;\n    return this;\n  }\n  isRequiredOrEmpty(errorMessage = this.locale.isRequiredOrEmpty, trim = true) {\n    this.required = true;\n    this.trim = trim;\n    this.emptyAllowed = true;\n    this.requiredMessage = errorMessage;\n    return this;\n  }\n  /**\n   * Define data verification rules based on conditions.\n   * @param condition\n   * @example\n   *\n   * ```js\n   * SchemaModel({\n   *   option: StringType().isOneOf(['a', 'b', 'other']),\n   *   other: StringType().when(schema => {\n   *     const { value } = schema.option;\n   *     return value === 'other' ? StringType().isRequired('Other required') : StringType();\n   *   })\n   * });\n   * ```\n   */\n  when(condition) {\n    this.addRule((value, data, fieldName) => {\n      return condition(this.$schemaSpec).check(value, data, fieldName);\n    }, undefined, true);\n    return this;\n  }\n  /**\n   * Check if the value is equal to the value of another field.\n   * @example\n   *\n   * ```js\n   * SchemaModel({\n   *   password: StringType().isRequired(),\n   *   confirmPassword: StringType().equalTo('password').isRequired()\n   * });\n   * ```\n   */\n  equalTo(fieldName, errorMessage = this.locale.equalTo) {\n    const errorMessageFunc = () => {\n      const type = getFieldType(this.$schemaSpec, fieldName, true);\n      return formatErrorMessage(errorMessage, {\n        toFieldName: (type === null || type === void 0 ? void 0 : type.fieldLabel) || fieldName\n      });\n    };\n    this.addRule((value, data) => {\n      return shallowEqual(value, get(data, fieldName));\n    }, errorMessageFunc);\n    return this;\n  }\n  /**\n   * After the field verification passes, proxy verification of other fields.\n   * @param options.checkIfValueExists When the value of other fields exists, the verification is performed (default: false)\n   * @example\n   *\n   * ```js\n   * SchemaModel({\n   *   password: StringType().isRequired().proxy(['confirmPassword']),\n   *   confirmPassword: StringType().equalTo('password').isRequired()\n   * });\n   * ```\n   */\n  proxy(fieldNames, options) {\n    this.otherFields = fieldNames;\n    this.proxyOptions = options || {};\n    return this;\n  }\n  /**\n   * Overrides the key name in error messages.\n   *\n   * @example\n   * ```js\n   * SchemaModel({\n   *  first_name: StringType().label('First name'),\n   *  age: NumberType().label('Age')\n   * });\n   * ```\n   */\n  label(label) {\n    this.fieldLabel = label;\n    return this;\n  }\n}\nexport default function getMixedType() {\n  return new MixedType();\n}","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/*!\n * set-value <https://github.com/jonschlinkert/set-value>\n *\n * Copyright (c) Jon Schlinkert (https://github.com/jonschlinkert).\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst {\n  deleteProperty\n} = Reflect;\nconst isPrimitive = require('is-primitive');\nconst isPlainObject = require('is-plain-object');\nconst isObject = value => {\n  return typeof value === 'object' && value !== null || typeof value === 'function';\n};\nconst isUnsafeKey = key => {\n  return key === '__proto__' || key === 'constructor' || key === 'prototype';\n};\nconst validateKey = key => {\n  if (!isPrimitive(key)) {\n    throw new TypeError('Object keys must be strings or symbols');\n  }\n  if (isUnsafeKey(key)) {\n    throw new Error(`Cannot set unsafe key: \"${key}\"`);\n  }\n};\nconst toStringKey = input => {\n  return Array.isArray(input) ? input.flat().map(String).join(',') : input;\n};\nconst createMemoKey = (input, options) => {\n  if (typeof input !== 'string' || !options) return input;\n  let key = input + ';';\n  if (options.arrays !== undefined) key += `arrays=${options.arrays};`;\n  if (options.separator !== undefined) key += `separator=${options.separator};`;\n  if (options.split !== undefined) key += `split=${options.split};`;\n  if (options.merge !== undefined) key += `merge=${options.merge};`;\n  if (options.preservePaths !== undefined) key += `preservePaths=${options.preservePaths};`;\n  return key;\n};\nconst memoize = (input, options, fn) => {\n  const key = toStringKey(options ? createMemoKey(input, options) : input);\n  validateKey(key);\n  const value = setValue.cache.get(key) || fn();\n  setValue.cache.set(key, value);\n  return value;\n};\nconst splitString = (input, options = {}) => {\n  const sep = options.separator || '.';\n  const preserve = sep === '/' ? false : options.preservePaths;\n  if (typeof input === 'string' && preserve !== false && /\\//.test(input)) {\n    return [input];\n  }\n  const parts = [];\n  let part = '';\n  const push = part => {\n    let number;\n    if (part.trim() !== '' && Number.isInteger(number = Number(part))) {\n      parts.push(number);\n    } else {\n      parts.push(part);\n    }\n  };\n  for (let i = 0; i < input.length; i++) {\n    const value = input[i];\n    if (value === '\\\\') {\n      part += input[++i];\n      continue;\n    }\n    if (value === sep) {\n      push(part);\n      part = '';\n      continue;\n    }\n    part += value;\n  }\n  if (part) {\n    push(part);\n  }\n  return parts;\n};\nconst split = (input, options) => {\n  if (options && typeof options.split === 'function') return options.split(input);\n  if (typeof input === 'symbol') return [input];\n  if (Array.isArray(input)) return input;\n  return memoize(input, options, () => splitString(input, options));\n};\nconst assignProp = (obj, prop, value, options) => {\n  validateKey(prop);\n\n  // Delete property when \"value\" is undefined\n  if (value === undefined) {\n    deleteProperty(obj, prop);\n  } else if (options && options.merge) {\n    const merge = options.merge === 'function' ? options.merge : Object.assign;\n\n    // Only merge plain objects\n    if (merge && isPlainObject(obj[prop]) && isPlainObject(value)) {\n      obj[prop] = merge(obj[prop], value);\n    } else {\n      obj[prop] = value;\n    }\n  } else {\n    obj[prop] = value;\n  }\n  return obj;\n};\nconst setValue = (target, path, value, options) => {\n  if (!path || !isObject(target)) return target;\n  const keys = split(path, options);\n  let obj = target;\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const next = keys[i + 1];\n    validateKey(key);\n    if (next === undefined) {\n      assignProp(obj, key, value, options);\n      break;\n    }\n    if (typeof next === 'number' && !Array.isArray(obj[key])) {\n      obj = obj[key] = [];\n      continue;\n    }\n    if (!isObject(obj[key])) {\n      obj[key] = {};\n    }\n    obj = obj[key];\n  }\n  return target;\n};\nsetValue.split = split;\nsetValue.cache = new Map();\nsetValue.clear = () => {\n  setValue.cache = new Map();\n};\nmodule.exports = setValue;","map":null,"metadata":{},"sourceType":"script"}
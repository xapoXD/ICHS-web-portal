{"ast":null,"code":"'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { useState, useRef, useCallback } from 'react';\nimport isNil from 'lodash/isNil';\nimport { TREE_NODE_DROP_POSITION } from \"../../internals/constants/index.js\";\nimport { useEventCallback } from \"../../internals/hooks/index.js\";\nimport { shallowEqual as equal, stringifyReactNode } from \"../../internals/utils/index.js\";\nimport { useItemDataKeys } from \"../../internals/Tree/TreeProvider.js\";\n/**\n * The gap between tree nodes.\n */\nvar TREE_NODE_GAP = 4;\n\n/**\n * Calculates the drop position of a tree node based on the clientY coordinate of a drag event\n * and the bounding rectangle of the tree node element.\n *\n * @param event - The drag event.\n * @param treeNodeElement - The element representing the tree node.\n * @returns The drop position of the tree node.\n */\nfunction calDropNodePosition(event, treeNodeElement) {\n  var clientY = event.clientY;\n  var _treeNodeElement$getB = treeNodeElement.getBoundingClientRect(),\n    top = _treeNodeElement$getB.top,\n    bottom = _treeNodeElement$getB.bottom;\n  var gap = TREE_NODE_GAP;\n\n  // bottom of node\n  if (clientY >= bottom - gap && clientY <= bottom) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM;\n  }\n\n  // top of node\n  if (clientY <= top + gap && clientY >= top) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_TOP;\n  }\n  if (clientY >= top + gap && clientY <= bottom - gap) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER;\n  }\n  return -1;\n}\n\n/**\n * Creates a drag preview element for tree nodes.\n */\nfunction createDragPreview(name, className) {\n  var dragPreview = document.createElement('div');\n  dragPreview.id = 'rs-tree-drag-preview';\n  dragPreview.dataset.testid = 'drag-preview';\n  dragPreview.innerHTML = name;\n  dragPreview.classList.add(className);\n  document.body.appendChild(dragPreview);\n  return dragPreview;\n}\n\n/**\n * Removes the drag preview element from the DOM.\n */\nfunction removeDragPreview() {\n  var _dragPreview$parentNo, _dragPreview$parentNo2;\n  var dragPreview = document.getElementById('rs-tree-drag-preview');\n  dragPreview === null || dragPreview === void 0 ? void 0 : (_dragPreview$parentNo = dragPreview.parentNode) === null || _dragPreview$parentNo === void 0 ? void 0 : (_dragPreview$parentNo2 = _dragPreview$parentNo.removeChild) === null || _dragPreview$parentNo2 === void 0 ? void 0 : _dragPreview$parentNo2.call(_dragPreview$parentNo, dragPreview);\n}\n/**\n * Custom hook for handling tree node dragging.\n */\nexport default function useTreeDrag(props) {\n  var _useItemDataKeys = useItemDataKeys(),\n    childrenKey = _useItemDataKeys.childrenKey,\n    valueKey = _useItemDataKeys.valueKey,\n    labelKey = _useItemDataKeys.labelKey;\n  var draggable = props.draggable,\n    flattenedNodes = props.flattenedNodes,\n    treeNodesRefs = props.treeNodesRefs,\n    onDragStart = props.onDragStart,\n    onDragEnter = props.onDragEnter,\n    onDragOver = props.onDragOver,\n    onDragLeave = props.onDragLeave,\n    onDragEnd = props.onDragEnd,\n    onDrop = props.onDrop,\n    prefix = props.prefix;\n  // current dragging node\n  var dragNode = useRef(null);\n  var _useState = useState(null),\n    dragOverNodeKey = _useState[0],\n    setDragOverNodeKey = _useState[1];\n  // drag node and it's children nodes key\n  var _useState2 = useState([]),\n    dragNodeKeys = _useState2[0],\n    setDragNodeKeys = _useState2[1];\n  var _useState3 = useState(null),\n    dropNodePosition = _useState3[0],\n    setDropNodePosition = _useState3[1];\n  var setDragNode = useCallback(function (node) {\n    dragNode.current = node;\n  }, []);\n\n  /**\n   * Retrieves an array of keys for the nodes in a tree starting from the specified drag node.\n   */\n  var getDragNodeKeys = useCallback(function (dragNode) {\n    var dragNodeKeys = [dragNode[valueKey]];\n    var traverse = function traverse(data) {\n      if ((data === null || data === void 0 ? void 0 : data.length) > 0) {\n        data.forEach(function (node) {\n          dragNodeKeys = dragNodeKeys.concat([node[valueKey]]);\n          if (node[childrenKey]) {\n            traverse(node[childrenKey]);\n          }\n        });\n      }\n    };\n    traverse(dragNode[childrenKey]);\n    return dragNodeKeys;\n  }, [childrenKey, valueKey]);\n\n  /**\n   * Removes the drag node from the data array.\n   *\n   */\n  var removeDragNode = useCallback(function (data, params) {\n    var dragNode = params.dragNode;\n    var traverse = function traverse(items, parent) {\n      for (var index = 0; index < items.length; index += 1) {\n        var item = items[index];\n        if (equal(item[valueKey], dragNode[valueKey])) {\n          items.splice(index, 1);\n          // when children is empty, delete children prop for hidden anchor\n          if (items.length === 0 && parent) {\n            delete parent.children;\n          }\n          break;\n        }\n        if (Array.isArray(item[childrenKey])) {\n          traverse(item[childrenKey], item);\n        }\n      }\n    };\n    traverse(data);\n  }, [childrenKey, valueKey]);\n\n  /**\n   * Creates a function that modifies a tree data structure based on drag and drop parameters.\n   */\n  var createDragTreeDataFunction = useCallback(function (params) {\n    return function (tree) {\n      var data = [].concat(tree);\n      var dragNode = params.dragNode,\n        dropNode = params.dropNode,\n        dropNodePosition = params.dropNodePosition;\n      var cloneDragNode = _extends({}, dragNode);\n      removeDragNode(data, params);\n      var updateTree = function updateTree(items) {\n        for (var index = 0; index < items.length; index += 1) {\n          var item = items[index];\n          if (equal(item[valueKey], dropNode[valueKey])) {\n            // drag to node inside\n            if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER) {\n              item[childrenKey] = isNil(item[childrenKey]) ? [] : item[childrenKey];\n              item[childrenKey].push(cloneDragNode);\n              break;\n            } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_TOP) {\n              // drag to top of node\n              items.splice(index, 0, cloneDragNode);\n              break;\n            } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM) {\n              // drag to bottom of node\n              items.splice(index + 1, 0, cloneDragNode);\n              break;\n            }\n          }\n          if (Array.isArray(item[childrenKey]) && item[childrenKey].length > 0) {\n            updateTree(item[childrenKey]);\n          }\n        }\n      };\n      updateTree(data);\n      return [].concat(data);\n    };\n  }, [childrenKey, removeDragNode, valueKey]);\n  var getDropData = useCallback(function (nodeData) {\n    var dragParams = {\n      dragNode: dragNode.current,\n      dropNode: nodeData,\n      dropNodePosition: dropNodePosition\n    };\n    return _extends({}, dragParams, {\n      createUpdateDataFunction: createDragTreeDataFunction(dragParams)\n    });\n  }, [createDragTreeDataFunction, dropNodePosition]);\n  var handleDragStart = useEventCallback(function (nodeData, event) {\n    if (draggable) {\n      var _event$dataTransfer;\n      var dragMoverNode = createDragPreview(stringifyReactNode(nodeData[labelKey]), prefix('drag-preview'));\n      (_event$dataTransfer = event.dataTransfer) === null || _event$dataTransfer === void 0 ? void 0 : _event$dataTransfer.setDragImage(dragMoverNode, 0, 0);\n      setDragNodeKeys(getDragNodeKeys(nodeData));\n      setDragNode(flattenedNodes[nodeData.refKey]);\n      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(nodeData, event);\n    }\n  });\n  var handleDragEnter = useEventCallback(function (nodeData, event) {\n    if (dragNodeKeys.some(function (d) {\n      return equal(d, nodeData[valueKey]);\n    })) {\n      return;\n    }\n    if (dragNode.current) {\n      setDragOverNodeKey(nodeData[valueKey]);\n      setDropNodePosition(calDropNodePosition(event, treeNodesRefs[nodeData.refKey]));\n    }\n    onDragEnter === null || onDragEnter === void 0 ? void 0 : onDragEnter(nodeData, event);\n  });\n  var handleDragOver = useEventCallback(function (nodeData, event) {\n    if (dragNodeKeys.some(function (d) {\n      return equal(d, nodeData[valueKey]);\n    })) {\n      event.dataTransfer.dropEffect = 'none';\n      return;\n    }\n    if (dragNode.current && equal(nodeData[valueKey], dragOverNodeKey)) {\n      var lastDropNodePosition = calDropNodePosition(event, treeNodesRefs[nodeData.refKey]);\n      if (lastDropNodePosition === dropNodePosition) return;\n      setDropNodePosition(lastDropNodePosition);\n    }\n    onDragOver === null || onDragOver === void 0 ? void 0 : onDragOver(nodeData, event);\n  });\n  var handleDragLeave = useEventCallback(function (nodeData, event) {\n    onDragLeave === null || onDragLeave === void 0 ? void 0 : onDragLeave(nodeData, event);\n  });\n  var handleDragEnd = useEventCallback(function (nodeData, event) {\n    removeDragPreview();\n    setDragNode(null);\n    setDragNodeKeys([]);\n    setDragOverNodeKey(null);\n    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(nodeData, event);\n  });\n  var handleDrop = useEventCallback(function (nodeData, event) {\n    if (dragNodeKeys.some(function (d) {\n      return equal(d, nodeData[valueKey]);\n    })) {\n      console.error('Cannot drag a node to itself and its children');\n    } else {\n      var dropData = getDropData(nodeData);\n      onDrop === null || onDrop === void 0 ? void 0 : onDrop(dropData, event);\n    }\n    removeDragPreview();\n    setDragNode(null);\n    setDragNodeKeys([]);\n    setDragOverNodeKey(null);\n  });\n  var dragEvents = {\n    onDragStart: handleDragStart,\n    onDragEnter: handleDragEnter,\n    onDragOver: handleDragOver,\n    onDragLeave: handleDragLeave,\n    onDragEnd: handleDragEnd,\n    onDrop: handleDrop\n  };\n  return {\n    dragNode: dragNode === null || dragNode === void 0 ? void 0 : dragNode.current,\n    dragOverNodeKey: dragOverNodeKey,\n    dropNodePosition: dropNodePosition,\n    dragEvents: dragEvents\n  };\n}","map":null,"metadata":{},"sourceType":"module"}
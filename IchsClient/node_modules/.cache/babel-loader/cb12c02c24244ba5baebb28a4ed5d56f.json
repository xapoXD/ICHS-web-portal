{"ast":null,"code":"import { useState, useCallback, useMemo, cloneElement, useRef, createElement, useEffect, forwardRef } from 'react';\nimport clsx from 'clsx';\nimport mergeRefs from 'react-merge-refs';\nimport { nanoid } from 'nanoid/non-secure';\nconst INDETERMINATE_STATE = 'indeterminate';\nconst dispatch = value => state => {\n  if (Array.isArray(state)) {\n    const index = state.indexOf(value);\n    if (index === -1) {\n      state.push(value);\n    } else {\n      state.splice(index, 1);\n    }\n    return [...state];\n  } else if (value !== '') {\n    return [value];\n  }\n  return !state;\n};\nconst useCheckboxState = ({\n  state: initialState = false,\n  onChange\n} = {}) => {\n  const [state, setState] = useState(() => {\n    if (typeof initialState === 'string' && initialState !== INDETERMINATE_STATE) {\n      return [initialState];\n    }\n    return initialState;\n  });\n  return {\n    state,\n    setState,\n    onChange: useCallback(e => {\n      const {\n        value\n      } = e.currentTarget;\n      setState(dispatch(value));\n      if (typeof onChange === 'function') {\n        onChange(e);\n      }\n    }, [onChange])\n  };\n};\nconst lockedStyles = {\n  pointerEvents: 'none'\n};\n/**\n * A simplier way to prevent checking when PCR is in locked mode.\n * This is way simplier than controlling the checkbox using\n * event handlers. Supports IE 11+\n */\nconst useLocked = ({\n  locked,\n  style\n}) => {\n  if (locked) {\n    return {\n      ...lockedStyles,\n      ...style\n    };\n  }\n  return style;\n};\nconst useIcon = icon => {\n  return useMemo(() => {\n    if (icon) {\n      let type = 'icon';\n      if (icon.type === 'img') {\n        type = 'image';\n      } else if (icon.type === 'svg') {\n        type = 'svg';\n      }\n      // icons that contain `type` substring\n      // won't fail with a word boundary search\n      const re = new RegExp(`\\\\b${type}\\\\b`);\n      return {\n        iconType: icon.props['data-type'] || type,\n        icon: icon.props.className && !re.test(icon.props.className) ? cloneElement(icon, {\n          ...icon.props,\n          className: clsx(icon.props.className, type)\n        }) : icon\n      };\n    }\n    return {};\n  }, [icon]);\n};\nconst isDefault = (animation, type) => {\n  if (type) {\n    return false;\n  }\n  return !animation || animation === 'smooth' || animation === 'pulse';\n};\n/**\n * Responsible for returning an object used by classnames\n * to properly add the className values to the .pretty element.\n */\nconst useClassNames = (props, isSwitch) => {\n  const {\n    animation,\n    bigger,\n    locked,\n    plain,\n    shape,\n    variant,\n    iconType,\n    hasFocus\n  } = props;\n  return {\n    'p-default': !isSwitch && isDefault(animation, iconType),\n    'p-bigger': bigger,\n    'p-locked': locked,\n    'p-plain': plain,\n    'p-has-focus': hasFocus,\n    [`p-${animation}`]: animation,\n    [`p-${shape}`]: shape,\n    [`p-${variant}`]: variant,\n    [`p-${iconType}`]: iconType\n  };\n};\nconst isBoolean = e => typeof e === 'boolean';\nconst isNullish = e => e === null || e === undefined;\nconst isIndeterminate = e => e === 'indeterminate';\n/**\n * A generic way to setup controlled components by\n * removing  state hook return results, setting `checked`,\n * and `value` props too.\n */\nconst useControlled = props => {\n  // remove state and state dispatch from the props\n  // eslint-disable-next-line prefer-const\n  let {\n    checked,\n    state,\n    setState,\n    value,\n    defaultValue,\n    ...rest\n  } = props;\n  // if a dispatcher is used, then we're good to run the rest\n  // of the logic\n  if (setState) {\n    // if state is defined and checked is NOT defined\n    // then use state to set the value of checked.\n    if ((isBoolean(state) || isIndeterminate(state)) && !isBoolean(checked) && isNullish(checked)) {\n      checked = !!state;\n    } else if (Array.isArray(state)) {\n      // otherwise set checked true if the value is contained\n      // within the state.\n      checked = state.includes(value);\n    } else if (isNullish(checked)) {\n      // The type is not a boolean and is probably a string.\n      // If you're attempting to use this hook in a different\n      // way, then you should considering controlling the component\n      // yourself. Object.is used here just in case ;)\n      checked = Object.is(state, value);\n    }\n    // preset the value prop in controlled mode to an empty\n    // string to prevent 'on' values. Use the defaultValue\n    // if provided\n    if (isNullish(value)) {\n      value = defaultValue || '';\n    }\n  }\n  return {\n    checked,\n    value,\n    state,\n    ...rest\n  };\n};\nconst PREFIX = 'pcr_';\nconst useUUID = () => useRef(PREFIX + nanoid(8)).current;\n\n/**\n * Filters out the noise of prop mayhem with PCR. This separates\n * all props from the native HTML props that will eventually get passed\n * to the input element. Generated PCR UUIDs are created here, unless\n * user has specified one of their own.\n */\nconst useCommonProps = props => {\n  const defaultId = useUUID();\n  const {\n    locked,\n    color,\n    variant,\n    animation,\n    children,\n    style,\n    id = defaultId,\n    className,\n    bigger,\n    hasFocus,\n    ...rest\n  } = props;\n  return {\n    locked,\n    color,\n    variant,\n    animation,\n    children,\n    id,\n    className,\n    bigger,\n    style,\n    hasFocus,\n    htmlProps: rest\n  };\n};\n\n/**\n * Responsible for extracting common props for radio and checkbox\n * controls.\n */\nconst useCheckboxRadioProps = props => {\n  const {\n    shape,\n    plain,\n    icon,\n    indeterminate,\n    hasFocus,\n    ...rest\n  } = props;\n  return {\n    shape,\n    plain,\n    icon,\n    indeterminate,\n    ...useCommonProps(rest)\n  };\n};\n\n/**\n * A tiny component to abstract away pretty-checkbox \"state\" div.\n * Shared by all components.\n */\nconst State = ({\n  color,\n  icon,\n  id,\n  children,\n  ...rest\n}) => {\n  return createElement(\"div\", {\n    className: clsx('state', color && `p-${color}`),\n    ...rest\n  }, icon, createElement(\"label\", {\n    htmlFor: id\n  }, children));\n};\nState.displayName = 'State';\nconst useIndeterminate = ({\n  checked,\n  state,\n  indeterminate: indeterminateFromProps\n}) => {\n  const [indeterminate, setStatus] = useState(false);\n  const ref = useRef(null);\n  useEffect(() => {\n    if (state !== undefined && ref.current) {\n      setStatus(state === 'indeterminate');\n    }\n  }, [state]);\n  // if a prop is passed mark the indeterminate state\n  // we should check to ensure state isn't set to indeterminate\n  // since we don't want ot clobber the state value if\n  // it is defined.\n  useEffect(() => {\n    if (state !== 'indeterminate' && ref.current && typeof indeterminateFromProps !== 'undefined') {\n      ref.current.checked = indeterminateFromProps;\n      // fix needs to come from pretty-checkbox\n      // ref.current.indeterminate = indeterminateFromProps;\n      setStatus(indeterminateFromProps);\n    }\n  }, [indeterminateFromProps, state]);\n  return {\n    ref,\n    'aria-checked': indeterminate ? 'mixed' : checked\n  };\n};\nconst Checkbox = forwardRef((props, ref) => {\n  const {\n    checked,\n    value,\n    state,\n    ...rest\n  } = useControlled(props);\n  const {\n    children,\n    locked,\n    color,\n    id,\n    className,\n    style,\n    indeterminate,\n    icon: propsIcon,\n    htmlProps\n  } = useCheckboxRadioProps(rest);\n  const {\n    ref: intRef,\n    ...aria\n  } = useIndeterminate({\n    state,\n    checked,\n    indeterminate\n  });\n  const styles = useLocked({\n    locked,\n    style\n  });\n  const {\n    icon,\n    iconType\n  } = useIcon(propsIcon);\n  return createElement(\"div\", {\n    style: styles,\n    className: clsx('pretty', useClassNames({\n      ...props,\n      iconType\n    }), className)\n  }, createElement(\"input\", {\n    ref: mergeRefs([ref, intRef]),\n    value: value,\n    type: \"checkbox\",\n    id: id,\n    checked: checked,\n    ...aria,\n    ...htmlProps\n  }), createElement(State, {\n    id: id,\n    icon: icon,\n    color: color\n  }, children));\n});\nCheckbox.displayName = 'Checkbox';\nconst useRadioState = ({\n  state: initialState = false,\n  onChange\n} = {}) => {\n  const [state, setState] = useState(initialState);\n  return {\n    state,\n    setState,\n    onChange: useCallback(e => {\n      const {\n        value\n      } = e.currentTarget;\n      setState(current => {\n        if (value !== '') {\n          return value;\n        }\n        return !current;\n      });\n      if (typeof onChange === 'function') {\n        onChange(e);\n      }\n    }, [onChange])\n  };\n};\nconst Radio = forwardRef((props, ref) => {\n  const {\n    checked,\n    value,\n    state,\n    ...rest\n  } = useControlled(props);\n  const {\n    shape = 'round',\n    children,\n    locked,\n    color,\n    id,\n    className,\n    style,\n    icon: propsIcon,\n    htmlProps\n  } = useCheckboxRadioProps(rest);\n  const styles = useLocked({\n    locked,\n    style\n  });\n  const {\n    icon,\n    iconType\n  } = useIcon(propsIcon);\n  return createElement(\"div\", {\n    style: styles,\n    className: clsx('pretty', useClassNames({\n      ...props,\n      shape,\n      iconType\n    }), className)\n  }, createElement(\"input\", {\n    ref: ref,\n    value: value,\n    type: \"radio\",\n    id: id,\n    checked: checked,\n    ...htmlProps\n  }), createElement(State, {\n    id: id,\n    icon: icon,\n    color: color\n  }, children));\n});\nRadio.displayName = 'Radio';\nconst handler = e => {\n  e.currentTarget.setAttribute('aria-checked', e.currentTarget.checked + '');\n};\n/**\n * A small hook to help manage correct aria-checked state when switch\n * is used as an uncontrolled component. We need this to run\n * for a11y purposes. FOr the `switch` role, `aria-checked` is required.\n */\nconst useAriaChecked = ({\n  setState,\n  checked\n}) => {\n  const ref = useRef(null);\n  useEffect(() => {\n    const elem = ref.current;\n    let bound = false;\n    if (!setState && !checked && elem) {\n      elem.setAttribute('aria-checked', elem.checked + '');\n      elem.addEventListener('change', handler);\n      bound = true;\n    }\n    return () => {\n      if (bound && elem) {\n        elem.removeEventListener('change', handler);\n      }\n    };\n  }, [setState, checked]);\n  return ref;\n};\nconst Switch = forwardRef((props, ref) => {\n  const {\n    checked,\n    value,\n    state,\n    ...rest\n  } = useControlled(props);\n  const {\n    children,\n    locked,\n    color,\n    id,\n    className,\n    style,\n    htmlProps\n  } = useCommonProps(rest);\n  const styles = useLocked({\n    locked,\n    style\n  });\n  const htmlRef = useAriaChecked({\n    setState: props.setState,\n    checked\n  });\n  return createElement(\"div\", {\n    style: styles,\n    className: clsx('pretty', 'p-switch', useClassNames(props, true), className)\n  }, createElement(\"input\", {\n    ref: mergeRefs([ref, htmlRef]),\n    type: \"checkbox\",\n    role: \"switch\",\n    value: value,\n    id: id,\n    \"aria-checked\": checked,\n    checked: checked,\n    ...htmlProps\n  }), createElement(State, {\n    id: id,\n    color: color\n  }, children));\n});\nSwitch.displayName = 'Switch';\nexport { Checkbox, Radio, Switch, useCheckboxState, useRadioState };","map":null,"metadata":{},"sourceType":"module"}
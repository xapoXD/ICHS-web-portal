{"ast":null,"code":"'use client';\n\nimport { useState, useEffect, useCallback } from 'react';\nimport uniq from 'lodash/uniq';\nimport remove from 'lodash/remove';\nimport { useEventCallback } from \"../../internals/hooks/index.js\";\nimport { removeAllChildrenValue, getOtherItemValuesByUnselectChild } from \"../utils.js\";\n\n/**\n * Get all parents of a node\n * @param node\n */\nvar getParents = function getParents(node) {\n  var parents = [];\n  if (!node.parent) {\n    return parents;\n  }\n  parents.push(node.parent);\n  parents = parents.concat(getParents(node.parent));\n  return parents;\n};\n\n/**\n * A hook that converts the value into a cascading value\n * @param props\n * @param flattenData\n */\nfunction useCascadeValue(props, flattenData) {\n  var valueKey = props.valueKey,\n    childrenKey = props.childrenKey,\n    uncheckableItemValues = props.uncheckableItemValues,\n    cascade = props.cascade,\n    valueProp = props.value,\n    onChange = props.onChange,\n    onCheck = props.onCheck;\n\n  /**\n   * Get the values of all children\n   */\n  var getChildrenValue = useCallback(function (item) {\n    var values = [];\n    if (!item[childrenKey]) {\n      return values;\n    }\n    item[childrenKey].forEach(function (n) {\n      if (uncheckableItemValues && !uncheckableItemValues.some(function (v) {\n        return v === n[valueKey];\n      })) {\n        values.push(n[valueKey]);\n      }\n      values = values.concat(getChildrenValue(n));\n    });\n    return values;\n  }, [childrenKey, uncheckableItemValues, valueKey]);\n  var splitValue = useCallback(function (item, checked, value) {\n    var itemValue = item[valueKey];\n    var childrenValue = getChildrenValue(item);\n    var parents = getParents(item);\n    var nextValue = [].concat(value);\n    var removedValue = [];\n    if (checked) {\n      nextValue.push(itemValue);\n\n      // Delete all values under the current node\n      removedValue = removedValue.concat(removeAllChildrenValue(nextValue, item, {\n        valueKey: valueKey,\n        childrenKey: childrenKey\n      }) || []);\n\n      // Traverse all ancestor nodes of the current node\n      // Then determine whether all the child nodes of these nodes are selected, and then they themselves must be selected\n      var _loop = function _loop(i) {\n        // Whether the parent node can be selected\n        var isCheckableParent = !(uncheckableItemValues !== null && uncheckableItemValues !== void 0 && uncheckableItemValues.some(function (v) {\n          return v === parents[i][valueKey];\n        }));\n        if (isCheckableParent) {\n          var isCheckAll = parents[i][childrenKey]\n          // Filter out options that are marked as not selectable\n          .filter(function (n) {\n            return !(uncheckableItemValues !== null && uncheckableItemValues !== void 0 && uncheckableItemValues.some(function (v) {\n              return v === n[valueKey];\n            }));\n          })\n          // Check if all nodes are selected\n          .every(function (n) {\n            return nextValue.some(function (v) {\n              return v === n[valueKey];\n            });\n          });\n          if (isCheckAll) {\n            // Add parent node value\n            nextValue.push(parents[i][valueKey]);\n\n            // Delete all values under the parent node\n            removedValue = removedValue.concat(removeAllChildrenValue(nextValue, parents[i], {\n              valueKey: valueKey,\n              childrenKey: childrenKey\n            }) || []);\n          }\n        }\n      };\n      for (var i = 0; i < parents.length; i++) {\n        _loop(i);\n      }\n    } else {\n      var tempValue = childrenValue.concat(parents.map(function (item) {\n        return item[valueKey];\n      }));\n      nextValue = nextValue.concat(getOtherItemValuesByUnselectChild(item, nextValue, {\n        valueKey: valueKey,\n        childrenKey: childrenKey\n      }));\n\n      // Delete related child and parent nodes\n      removedValue = remove(nextValue, function (v) {\n        // Delete yourself\n        if (v === itemValue) {\n          return true;\n        }\n        return tempValue.some(function (n) {\n          return n === v;\n        });\n      });\n    }\n    var uniqValue = uniq(nextValue);\n    var uniqRemovedValue = uniq(removedValue);\n    return {\n      value: uniqValue,\n      removedValue: uniqRemovedValue\n    };\n  }, [valueKey, childrenKey, uncheckableItemValues, getChildrenValue]);\n  var transformValue = useCallback(function (value) {\n    if (value === void 0) {\n      value = [];\n    }\n    if (!cascade) {\n      return value;\n    }\n    var tempRemovedValue = [];\n    var nextValue = [];\n    var _loop2 = function _loop2(i) {\n        // If the value in the current value is already in the deleted list, it will not be processed\n        if (tempRemovedValue.some(function (v) {\n          return v === value[i];\n        })) {\n          return 0; // continue\n        }\n\n        var item = flattenData.find(function (v) {\n          return v[valueKey] === value[i];\n        });\n        if (!item) {\n          return 0; // continue\n        }\n\n        var sv = splitValue(item, true, value);\n        tempRemovedValue = uniq(tempRemovedValue.concat(sv.removedValue));\n\n        // Get all relevant values\n        nextValue = uniq(nextValue.concat(sv.value));\n      },\n      _ret;\n    for (var i = 0; i < value.length; i++) {\n      _ret = _loop2(i);\n      if (_ret === 0) continue;\n    }\n\n    // Finally traverse all nextValue, and delete if its parent node is also nextValue\n    return nextValue.filter(function (v) {\n      var item = flattenData.find(function (n) {\n        return n[valueKey] === v;\n      });\n      if (item !== null && item !== void 0 && item.parent && nextValue.some(function (v) {\n        var _item$parent;\n        return v === ((_item$parent = item.parent) === null || _item$parent === void 0 ? void 0 : _item$parent[valueKey]);\n      })) {\n        return false;\n      }\n      return true;\n    });\n  }, [cascade, flattenData, splitValue, valueKey]);\n  var _useState = useState(transformValue(valueProp) || []),\n    value = _useState[0],\n    setValue = _useState[1];\n  useEffect(function () {\n    // Update value when valueProp is updated.\n    setValue(transformValue(valueProp) || []);\n  }, [transformValue, valueProp]);\n  var handleCheck = useEventCallback(function (node, event, checked) {\n    var nodeValue = node[valueKey];\n    var nextValue = [];\n    if (cascade) {\n      nextValue = splitValue(node, checked, value).value;\n    } else {\n      nextValue = [].concat(value);\n      if (checked) {\n        nextValue.push(nodeValue);\n      } else {\n        nextValue = nextValue.filter(function (n) {\n          return n !== nodeValue;\n        });\n      }\n    }\n    setValue(nextValue);\n    onChange === null || onChange === void 0 ? void 0 : onChange(nextValue, event);\n    onCheck === null || onCheck === void 0 ? void 0 : onCheck(nextValue, node, checked, event);\n  });\n  return {\n    value: value,\n    setValue: setValue,\n    splitValue: splitValue,\n    handleCheck: handleCheck\n  };\n}\nexport default useCascadeValue;","map":null,"metadata":{},"sourceType":"module"}
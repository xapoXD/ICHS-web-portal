{"ast":null,"code":"'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _isNil from \"lodash/isNil\";\nimport { CHECK_STATE } from \"../internals/constants/index.js\";\nimport { attachParent } from \"../internals/utils/index.js\";\nimport { formatNodeRefKey } from \"../Tree/utils/index.js\";\n\n/**\n * Retrieves the children of a given parent node from a flattened node map.\n */\nfunction getChildrenByFlattenNodes(nodes, parent) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return [];\n  }\n  return Object.values(nodes).filter(function (item) {\n    var _item$parent;\n    return (item === null || item === void 0 ? void 0 : (_item$parent = item.parent) === null || _item$parent === void 0 ? void 0 : _item$parent.refKey) === parent.refKey && item.refKey && !nodes[item.refKey].uncheckable;\n  });\n}\n\n/**\n * Checks if every child of a given parent node is checked.\n */\nexport function isEveryChildChecked(parent, options) {\n  var nodes = options.nodes,\n    childrenKey = options.childrenKey;\n  if (_isNil(parent.refKey) || _isNil(nodes[parent.refKey])) {\n    return false;\n  }\n  var children = getChildrenByFlattenNodes(nodes, parent);\n  if (!children.length) {\n    var _nodes$parent$refKey$;\n    return (_nodes$parent$refKey$ = nodes[parent.refKey].check) !== null && _nodes$parent$refKey$ !== void 0 ? _nodes$parent$refKey$ : false;\n  }\n  return children.every(function (child) {\n    var _child$childrenKey;\n    if ((child === null || child === void 0 ? void 0 : (_child$childrenKey = child[childrenKey]) === null || _child$childrenKey === void 0 ? void 0 : _child$childrenKey.length) > 0) {\n      // fix: #3559\n      return isEveryChildChecked(child, {\n        nodes: nodes,\n        childrenKey: childrenKey\n      });\n    }\n    return !_isNil(child.refKey) && nodes[child.refKey].check;\n  });\n}\n\n/**\n * Checks if any child node is checked.\n */\nexport function isSomeChildChecked(nodes, parent, childrenKey) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return false;\n  }\n  var children = getChildrenByFlattenNodes(nodes, parent);\n  return children.some(function (child) {\n    var _child$childrenKey2;\n    if ((child === null || child === void 0 ? void 0 : (_child$childrenKey2 = child[childrenKey]) === null || _child$childrenKey2 === void 0 ? void 0 : _child$childrenKey2.length) > 0) {\n      return isSomeChildChecked(nodes, child, childrenKey);\n    }\n    return !_isNil(child.refKey) && nodes[child.refKey].check;\n  });\n}\n\n/**\n * Checks if any node in the data has a grandchild.\n */\nexport function hasGrandchild(data, childrenKey) {\n  return data.some(function (node) {\n    return Array.isArray(node[childrenKey]);\n  });\n}\n\n/**\n * Checks if all sibling nodes of a given node are uncheckable.\n */\nexport function isAllSiblingNodeUncheckable(node, nodes, uncheckableItemValues, valueKey) {\n  var list = [];\n  var parentNodeRefKey = node.parent ? node.parent.refKey : '';\n  Object.keys(nodes).forEach(function (refKey) {\n    var _curNode$parent;\n    var curNode = nodes[refKey];\n    if (_isNil(node.parent) && _isNil(curNode.parent)) {\n      list.push(curNode);\n    } else if (((_curNode$parent = curNode.parent) === null || _curNode$parent === void 0 ? void 0 : _curNode$parent.refKey) === parentNodeRefKey) {\n      list.push(curNode);\n    }\n  });\n  return list.every(function (node) {\n    return isNodeUncheckable(node, {\n      uncheckableItemValues: uncheckableItemValues,\n      valueKey: valueKey\n    });\n  });\n}\n\n/**\n * Checks if every first-level node is uncheckable based on the provided criteria.\n */\nexport function isEveryFirstLevelNodeUncheckable(nodes, uncheckableItemValues, valueKey) {\n  var list = [];\n  Object.keys(nodes).forEach(function (refKey) {\n    var curNode = nodes[refKey];\n    if (!curNode.parent) {\n      list.push(curNode);\n    }\n  });\n  return list.every(function (node) {\n    return isNodeUncheckable(node, {\n      uncheckableItemValues: uncheckableItemValues,\n      valueKey: valueKey\n    });\n  });\n}\n\n/**\n * Checks if a node is uncheckable.\n */\nexport function isNodeUncheckable(node, props) {\n  var _props$uncheckableIte = props.uncheckableItemValues,\n    uncheckableItemValues = _props$uncheckableIte === void 0 ? [] : _props$uncheckableIte,\n    valueKey = props.valueKey;\n  return uncheckableItemValues.some(function (value) {\n    return node[valueKey] === value;\n  });\n}\nexport function getFormattedTree(nodes, data, props) {\n  var childrenKey = props.childrenKey,\n    cascade = props.cascade;\n  return data.map(function (node) {\n    var formatted = _extends({}, node);\n    var curNode = nodes[node.refKey];\n    if (curNode) {\n      var _node$childrenKey;\n      var checkState = !_isUndefined(cascade) ? getNodeCheckState(curNode, {\n        cascade: cascade,\n        nodes: nodes,\n        childrenKey: childrenKey\n      }) : undefined;\n      formatted.check = curNode.check;\n      formatted.uncheckable = curNode.uncheckable;\n      attachParent(formatted, curNode.parent);\n      formatted.checkState = checkState;\n      if (((_node$childrenKey = node[childrenKey]) === null || _node$childrenKey === void 0 ? void 0 : _node$childrenKey.length) > 0) {\n        formatted[childrenKey] = getFormattedTree(nodes, formatted[childrenKey], props);\n      }\n    }\n    return formatted;\n  });\n}\n\n/**\n * Determines the disabled state of a tree node.\n */\nexport function getDisabledState(nodes, node, props) {\n  var _props$disabledItemVa = props.disabledItemValues,\n    disabledItemValues = _props$disabledItemVa === void 0 ? [] : _props$disabledItemVa,\n    valueKey = props.valueKey;\n  if (!_isNil(node.refKey) && _isNil(nodes[node.refKey])) {\n    return false;\n  }\n  return disabledItemValues.some(function (value) {\n    return node.refKey && nodes[node.refKey][valueKey] === value;\n  });\n}\n\n/**\n * Returns the default value for the check tree.\n */\nexport function getCheckTreeDefaultValue(value, uncheckableItemValues) {\n  if (Array.isArray(value) && Array.isArray(uncheckableItemValues)) {\n    return value.filter(function (v) {\n      return !uncheckableItemValues.includes(v);\n    });\n  }\n  return [];\n}\n\n/**\n * Retrieves the selected items from the given nodes.\n */\nexport function getSelectedItems(nodes, values) {\n  var checkedItems = [];\n  values.forEach(function (value) {\n    var refKey = formatNodeRefKey(value);\n    var node = nodes[refKey];\n    if (!_isNil(node)) {\n      checkedItems.push(node);\n    }\n  });\n  return checkedItems;\n}\n/**\n * Calculates the check state of a node in a check tree.\n */\nexport function getNodeCheckState(node, options) {\n  var nodes = options.nodes,\n    cascade = options.cascade,\n    childrenKey = options.childrenKey;\n  if (node.refKey === undefined) {\n    return CHECK_STATE.UNCHECK;\n  }\n  if (_isNil(nodes[node.refKey])) {\n    return CHECK_STATE.UNCHECK;\n  }\n  if (!node[childrenKey] || !node[childrenKey].length || !cascade) {\n    nodes[node.refKey].checkAll = false;\n    return node.check ? CHECK_STATE.CHECK : CHECK_STATE.UNCHECK;\n  }\n  if (isEveryChildChecked(node, {\n    nodes: nodes,\n    childrenKey: childrenKey\n  })) {\n    nodes[node.refKey].checkAll = true;\n    nodes[node.refKey].check = true;\n    return CHECK_STATE.CHECK;\n  }\n  if (isSomeChildChecked(nodes, node, childrenKey)) {\n    nodes[node.refKey].checkAll = false;\n    return CHECK_STATE.INDETERMINATE;\n  }\n  return CHECK_STATE.UNCHECK;\n}","map":null,"metadata":{},"sourceType":"module"}
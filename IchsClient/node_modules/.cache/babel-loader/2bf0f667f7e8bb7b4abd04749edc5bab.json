{"ast":null,"code":"import { getFieldType, getFieldValue } from './MixedType';\nimport { set, get, isEmpty, pathTransform } from './utils';\nexport class Schema {\n  constructor(schema) {\n    this.checkResult = {};\n    this.$spec = schema;\n  }\n  getFieldType(fieldName, nestedObject) {\n    return getFieldType(this.$spec, fieldName, nestedObject);\n  }\n  setFieldCheckResult(fieldName, checkResult, nestedObject) {\n    if (nestedObject) {\n      const namePath = fieldName.split('.').join('.object.');\n      set(this.checkResult, namePath, checkResult);\n      return;\n    }\n    this.checkResult[fieldName] = checkResult;\n  }\n  setSchemaOptionsForAllType(data) {\n    if (data === this.data) {\n      return;\n    }\n    Object.entries(this.$spec).forEach(([key, type]) => {\n      type.setSchemaOptions(this.$spec, data === null || data === void 0 ? void 0 : data[key]);\n    });\n    this.data = data;\n  }\n  /**\n   * Get the check result of the schema\n   * @returns CheckResult<ErrorMsgType | string>\n   */\n  getCheckResult(path, result = this.checkResult) {\n    if (path) {\n      return (result === null || result === void 0 ? void 0 : result[path]) || get(result, pathTransform(path)) || {\n        hasError: false\n      };\n    }\n    return result;\n  }\n  /**\n   * Get the error messages of the schema\n   */\n  getErrorMessages(path, result = this.checkResult) {\n    let messages = [];\n    if (path) {\n      const {\n        errorMessage,\n        object,\n        array\n      } = (result === null || result === void 0 ? void 0 : result[path]) || get(result, pathTransform(path)) || {};\n      if (errorMessage) {\n        messages = [errorMessage];\n      } else if (object) {\n        messages = Object.keys(object).map(key => {\n          var _a;\n          return (_a = object[key]) === null || _a === void 0 ? void 0 : _a.errorMessage;\n        });\n      } else if (array) {\n        messages = array.map(item => item === null || item === void 0 ? void 0 : item.errorMessage);\n      }\n    } else {\n      messages = Object.keys(result).map(key => {\n        var _a;\n        return (_a = result[key]) === null || _a === void 0 ? void 0 : _a.errorMessage;\n      });\n    }\n    return messages.filter(Boolean);\n  }\n  /**\n   * Get all the keys of the schema\n   */\n  getKeys() {\n    return Object.keys(this.$spec);\n  }\n  /**\n   * Get the schema specification\n   */\n  getSchemaSpec() {\n    return this.$spec;\n  }\n  checkForField(fieldName, data, options = {}) {\n    var _a;\n    this.setSchemaOptionsForAllType(data);\n    const {\n      nestedObject\n    } = options;\n    const fieldChecker = this.getFieldType(fieldName, nestedObject);\n    if (!fieldChecker) {\n      // fieldValue can be anything if no schema defined\n      return {\n        hasError: false\n      };\n    }\n    const fieldValue = getFieldValue(data, fieldName, nestedObject);\n    const checkResult = fieldChecker.check(fieldValue, data, fieldName);\n    this.setFieldCheckResult(fieldName, checkResult, nestedObject);\n    if (!checkResult.hasError) {\n      const {\n        checkIfValueExists\n      } = fieldChecker.proxyOptions;\n      // Check other fields if the field depends on them for validation\n      (_a = fieldChecker.otherFields) === null || _a === void 0 ? void 0 : _a.forEach(field => {\n        if (checkIfValueExists) {\n          if (!isEmpty(getFieldValue(data, field, nestedObject))) {\n            this.checkForField(field, data, options);\n          }\n          return;\n        }\n        this.checkForField(field, data, options);\n      });\n    }\n    return checkResult;\n  }\n  checkForFieldAsync(fieldName, data, options = {}) {\n    this.setSchemaOptionsForAllType(data);\n    const {\n      nestedObject\n    } = options;\n    const fieldChecker = this.getFieldType(fieldName, nestedObject);\n    if (!fieldChecker) {\n      // fieldValue can be anything if no schema defined\n      return Promise.resolve({\n        hasError: false\n      });\n    }\n    const fieldValue = getFieldValue(data, fieldName, nestedObject);\n    const checkResult = fieldChecker.checkAsync(fieldValue, data, fieldName);\n    return checkResult.then(async result => {\n      var _a;\n      this.setFieldCheckResult(fieldName, result, nestedObject);\n      if (!result.hasError) {\n        const {\n          checkIfValueExists\n        } = fieldChecker.proxyOptions;\n        const checkAll = [];\n        // Check other fields if the field depends on them for validation\n        (_a = fieldChecker.otherFields) === null || _a === void 0 ? void 0 : _a.forEach(field => {\n          if (checkIfValueExists) {\n            if (!isEmpty(getFieldValue(data, field, nestedObject))) {\n              checkAll.push(this.checkForFieldAsync(field, data, options));\n            }\n            return;\n          }\n          checkAll.push(this.checkForFieldAsync(field, data, options));\n        });\n        await Promise.all(checkAll);\n      }\n      return result;\n    });\n  }\n  check(data) {\n    const checkResult = {};\n    Object.keys(this.$spec).forEach(key => {\n      if (typeof data === 'object') {\n        checkResult[key] = this.checkForField(key, data);\n      }\n    });\n    return checkResult;\n  }\n  checkAsync(data) {\n    const checkResult = {};\n    const promises = [];\n    const keys = [];\n    Object.keys(this.$spec).forEach(key => {\n      keys.push(key);\n      promises.push(this.checkForFieldAsync(key, data));\n    });\n    return Promise.all(promises).then(values => {\n      for (let i = 0; i < values.length; i += 1) {\n        checkResult[keys[i]] = values[i];\n      }\n      return checkResult;\n    });\n  }\n}\nexport function SchemaModel(o) {\n  return new Schema(o);\n}\nSchemaModel.combine = function combine(...specs) {\n  return new Schema(specs.map(model => model.$spec).reduce((accumulator, currentValue) => Object.assign(accumulator, currentValue), {}));\n};","map":null,"metadata":{},"sourceType":"module"}
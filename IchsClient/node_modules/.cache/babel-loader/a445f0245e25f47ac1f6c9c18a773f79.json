{"ast":null,"code":"'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { setYear, setMonth, setDate, setHours, setMinutes, setSeconds } from \"../internals/utils/date/index.js\";\nimport { safeSetSelection } from \"../internals/utils/index.js\";\nexport function getPatternGroups(format, pattern) {\n  var _format$match;\n  return ((_format$match = format.match(new RegExp(\"(\" + pattern + \")+\"))) === null || _format$match === void 0 ? void 0 : _format$match[0]) || '';\n}\nexport function getSelectIndexGap(options) {\n  var pattern = options.pattern,\n    formatStr = options.formatStr,\n    valueOffset = options.valueOffset,\n    selectedMonth = options.selectedMonth,\n    localize = options.localize;\n  var gap = 0;\n  var monthIsAbbreviated = formatStr.includes('MMM');\n  var monthIsFull = formatStr.includes('MMMM');\n\n  // If the month is abbreviated or full, the gap needs to be adjusted.\n  if (monthIsAbbreviated || monthIsFull) {\n    var isSelectedMonth = pattern === 'M';\n\n    // If the selected is the month, and the valueOffset is null,\n    // it means that the delete key is pressed, and the default pattern is displayed, and the gap is 0 at this time.\n    if (isSelectedMonth && valueOffset === null) {\n      return 0;\n    }\n\n    // If the month is null and the valueOffset is 0, the month will not be updated, and the gap is 0 at this time.\n    if (selectedMonth === null && valueOffset === 0) {\n      return 0;\n    }\n    var month = selectedMonth ? selectedMonth + (isSelectedMonth ? valueOffset || 0 : 0) : 1;\n    if (month > 12) {\n      month = 1;\n    } else if (month === 0) {\n      month = 12;\n    }\n    var monthStr = localize === null || localize === void 0 ? void 0 : localize.month(month - 1, {\n      width: monthIsFull ? 'wide' : 'abbreviated'\n    });\n    gap = monthStr.length - (monthIsFull ? 4 : 3);\n  }\n  return gap;\n}\nexport function getDatePattern(options) {\n  var selectionIndex = options.selectionIndex,\n    _options$positionOffs = options.positionOffset,\n    positionOffset = _options$positionOffs === void 0 ? -1 : _options$positionOffs,\n    formatStr = options.formatStr,\n    dateString = options.dateString,\n    valueOffset = options.valueOffset,\n    selectedMonth = options.selectedMonth,\n    localize = options.localize;\n  var pattern = formatStr.charAt(selectionIndex || 0);\n  if (selectionIndex < 0 || selectionIndex > dateString.length - 1) {\n    pattern = formatStr.trim().charAt(0);\n    return pattern;\n  }\n  var gap = 0;\n  if (isCursorAfterMonth(selectionIndex, formatStr)) {\n    gap = getSelectIndexGap({\n      pattern: pattern,\n      formatStr: formatStr,\n      valueOffset: valueOffset,\n      selectedMonth: selectedMonth,\n      localize: localize\n    });\n  }\n  pattern = formatStr.charAt(selectionIndex - gap);\n\n  // If the pattern is not a letter, then get the pattern from the previous or next letter.\n  if (!pattern.match(/[y|d|M|H|h|m|s|a]/)) {\n    var nextIndex = selectionIndex + positionOffset;\n    pattern = getDatePattern(_extends({}, options, {\n      selectionIndex: nextIndex\n    }));\n  }\n  return pattern;\n}\n\n// Determine whether the cursor is after the month.\n// If the currently operated field is after the month, the selected field needs to be moved backward.\nexport function isCursorAfterMonth(cursorIndex, formatStr) {\n  return cursorIndex > formatStr.indexOf('M');\n}\nexport function getInputSelectedState(options) {\n  var input = options.input,\n    direction = options.direction,\n    formatStr = options.formatStr,\n    localize = options.localize,\n    selectedMonth = options.selectedMonth,\n    dateString = options.dateString,\n    _options$valueOffset = options.valueOffset,\n    valueOffset = _options$valueOffset === void 0 ? 0 : _options$valueOffset;\n  var getPatternSelectedIndexes = function getPatternSelectedIndexes(pattern) {\n    var selectionStart = formatStr.indexOf(pattern);\n    var selectionEnd = formatStr.lastIndexOf(pattern) + 1;\n    var gap = getSelectIndexGap({\n      pattern: pattern,\n      formatStr: formatStr,\n      valueOffset: valueOffset,\n      selectedMonth: selectedMonth,\n      localize: localize\n    });\n    var isSelectedMonth = pattern === 'M';\n    var isNullMonth = selectedMonth === null && !(isSelectedMonth && valueOffset !== 0);\n\n    // If the month is null and the valueOffset is 0, the month will not be updated, and the gap is 0 at this time.\n    if (isNullMonth) {\n      return {\n        selectionStart: selectionStart,\n        selectionEnd: selectionEnd\n      };\n    }\n    if (isSelectedMonth) {\n      return {\n        selectionStart: selectionStart,\n        selectionEnd: selectionEnd + gap\n      };\n    }\n    if (isCursorAfterMonth(selectionStart, formatStr)) {\n      return {\n        selectionStart: selectionStart + gap,\n        selectionEnd: selectionEnd + gap\n      };\n    }\n    return {\n      selectionStart: selectionStart,\n      selectionEnd: selectionEnd\n    };\n  };\n  if (typeof input.selectionEnd === 'number' && typeof input.selectionStart === 'number') {\n    var selectionIndex = input.selectionStart;\n    var positionOffset = -1;\n    if (direction === 'left') {\n      selectionIndex = input.selectionStart - 1;\n    } else if (direction === 'right') {\n      selectionIndex = input.selectionEnd + 1;\n      positionOffset = 1;\n    }\n    var datePattern = getDatePattern({\n      selectionIndex: selectionIndex,\n      positionOffset: positionOffset,\n      formatStr: formatStr,\n      dateString: dateString,\n      valueOffset: valueOffset,\n      selectedMonth: selectedMonth,\n      localize: localize\n    });\n    var indexes = getPatternSelectedIndexes(datePattern);\n    return _extends({\n      selectedPattern: datePattern\n    }, indexes);\n  }\n  return {\n    selectedPattern: 'y',\n    selectionStart: 0,\n    selectionEnd: 0\n  };\n}\nexport function validateDateTime(type, value) {\n  switch (type) {\n    case 'year':\n      if (value < 1 || value > 9999) {\n        return false;\n      }\n      break;\n    case 'month':\n      if (value < 1 || value > 12) {\n        return false;\n      }\n      break;\n    case 'day':\n      if (value < 1 || value > 31) {\n        return false;\n      }\n      break;\n    case 'hour':\n      if (value < 0 || value > 23) {\n        return false;\n      }\n      break;\n    case 'minute':\n      if (value < 0 || value > 59) {\n        return false;\n      }\n      break;\n    case 'second':\n      if (value < 0 || value > 59) {\n        return false;\n      }\n      break;\n    default:\n      return false;\n    // Invalid type\n  }\n\n  return true;\n}\nexport function modifyDate(date, type, value) {\n  switch (type) {\n    case 'year':\n      return setYear(date, value);\n    case 'month':\n      return setMonth(date, value - 1);\n    case 'day':\n      return setDate(date, value);\n    case 'hour':\n      return setHours(date, value);\n    case 'minute':\n      return setMinutes(date, value);\n    case 'second':\n      return setSeconds(date, value);\n  }\n  return date;\n}\nexport function useInputSelection(input) {\n  return function setSelectionRange(selectionStart, selectionEnd) {\n    var isTest = input.current.dataset.test === 'true';\n    if (isTest) {\n      safeSetSelection(input.current, selectionStart, selectionEnd);\n      return;\n    }\n    requestAnimationFrame(function () {\n      safeSetSelection(input.current, selectionStart, selectionEnd);\n    });\n  };\n}","map":null,"metadata":{},"sourceType":"module"}